// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

pub enum ServerVersionCmdOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ServerVersionCmd<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ServerVersionCmd<'a> {
  type Inner = ServerVersionCmd<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ServerVersionCmd<'a> {
  pub const VT_SERVER_VERSION: flatbuffers::VOffsetT = 4;
  pub const VT_CLIENT_WAN_IP: flatbuffers::VOffsetT = 6;
  pub const VT_CLIENT_WAN_PORT: flatbuffers::VOffsetT = 8;
  pub const VT_HEART_TYPE: flatbuffers::VOffsetT = 10;
  pub const VT_HEART_CLIENT_INTERVAL: flatbuffers::VOffsetT = 12;
  pub const VT_CHECK_SERVER_INTERVAL: flatbuffers::VOffsetT = 14;
  pub const VT_SERVER_ID: flatbuffers::VOffsetT = 16;
  pub const VT_SERVER_TIME_UTC: flatbuffers::VOffsetT = 18;
  pub const VT_SERVER_TIME: flatbuffers::VOffsetT = 20;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ServerVersionCmd { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ServerVersionCmdArgs<'args>
  ) -> flatbuffers::WIPOffset<ServerVersionCmd<'bldr>> {
    let mut builder = ServerVersionCmdBuilder::new(_fbb);
    builder.add_server_time(args.server_time);
    builder.add_server_time_utc(args.server_time_utc);
    builder.add_server_id(args.server_id);
    builder.add_check_server_interval(args.check_server_interval);
    builder.add_heart_client_interval(args.heart_client_interval);
    builder.add_client_wan_port(args.client_wan_port);
    if let Some(x) = args.client_wan_ip { builder.add_client_wan_ip(x); }
    if let Some(x) = args.server_version { builder.add_server_version(x); }
    builder.add_heart_type(args.heart_type);
    builder.finish()
  }


  #[inline]
  pub fn server_version(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ServerVersionCmd::VT_SERVER_VERSION, None)}
  }
  #[inline]
  pub fn client_wan_ip(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ServerVersionCmd::VT_CLIENT_WAN_IP, None)}
  }
  #[inline]
  pub fn client_wan_port(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ServerVersionCmd::VT_CLIENT_WAN_PORT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn heart_type(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(ServerVersionCmd::VT_HEART_TYPE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn heart_client_interval(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(ServerVersionCmd::VT_HEART_CLIENT_INTERVAL, Some(0)).unwrap()}
  }
  #[inline]
  pub fn check_server_interval(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(ServerVersionCmd::VT_CHECK_SERVER_INTERVAL, Some(0)).unwrap()}
  }
  #[inline]
  pub fn server_id(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ServerVersionCmd::VT_SERVER_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn server_time_utc(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(ServerVersionCmd::VT_SERVER_TIME_UTC, Some(0)).unwrap()}
  }
  #[inline]
  pub fn server_time(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(ServerVersionCmd::VT_SERVER_TIME, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for ServerVersionCmd<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("server_version", Self::VT_SERVER_VERSION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("client_wan_ip", Self::VT_CLIENT_WAN_IP, false)?
     .visit_field::<i32>("client_wan_port", Self::VT_CLIENT_WAN_PORT, false)?
     .visit_field::<u8>("heart_type", Self::VT_HEART_TYPE, false)?
     .visit_field::<u32>("heart_client_interval", Self::VT_HEART_CLIENT_INTERVAL, false)?
     .visit_field::<u32>("check_server_interval", Self::VT_CHECK_SERVER_INTERVAL, false)?
     .visit_field::<i32>("server_id", Self::VT_SERVER_ID, false)?
     .visit_field::<u64>("server_time_utc", Self::VT_SERVER_TIME_UTC, false)?
     .visit_field::<u64>("server_time", Self::VT_SERVER_TIME, false)?
     .finish();
    Ok(())
  }
}
pub struct ServerVersionCmdArgs<'a> {
    pub server_version: Option<flatbuffers::WIPOffset<&'a str>>,
    pub client_wan_ip: Option<flatbuffers::WIPOffset<&'a str>>,
    pub client_wan_port: i32,
    pub heart_type: u8,
    pub heart_client_interval: u32,
    pub check_server_interval: u32,
    pub server_id: i32,
    pub server_time_utc: u64,
    pub server_time: u64,
}
impl<'a> Default for ServerVersionCmdArgs<'a> {
  #[inline]
  fn default() -> Self {
    ServerVersionCmdArgs {
      server_version: None,
      client_wan_ip: None,
      client_wan_port: 0,
      heart_type: 0,
      heart_client_interval: 0,
      check_server_interval: 0,
      server_id: 0,
      server_time_utc: 0,
      server_time: 0,
    }
  }
}

pub struct ServerVersionCmdBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ServerVersionCmdBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_server_version(&mut self, server_version: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ServerVersionCmd::VT_SERVER_VERSION, server_version);
  }
  #[inline]
  pub fn add_client_wan_ip(&mut self, client_wan_ip: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ServerVersionCmd::VT_CLIENT_WAN_IP, client_wan_ip);
  }
  #[inline]
  pub fn add_client_wan_port(&mut self, client_wan_port: i32) {
    self.fbb_.push_slot::<i32>(ServerVersionCmd::VT_CLIENT_WAN_PORT, client_wan_port, 0);
  }
  #[inline]
  pub fn add_heart_type(&mut self, heart_type: u8) {
    self.fbb_.push_slot::<u8>(ServerVersionCmd::VT_HEART_TYPE, heart_type, 0);
  }
  #[inline]
  pub fn add_heart_client_interval(&mut self, heart_client_interval: u32) {
    self.fbb_.push_slot::<u32>(ServerVersionCmd::VT_HEART_CLIENT_INTERVAL, heart_client_interval, 0);
  }
  #[inline]
  pub fn add_check_server_interval(&mut self, check_server_interval: u32) {
    self.fbb_.push_slot::<u32>(ServerVersionCmd::VT_CHECK_SERVER_INTERVAL, check_server_interval, 0);
  }
  #[inline]
  pub fn add_server_id(&mut self, server_id: i32) {
    self.fbb_.push_slot::<i32>(ServerVersionCmd::VT_SERVER_ID, server_id, 0);
  }
  #[inline]
  pub fn add_server_time_utc(&mut self, server_time_utc: u64) {
    self.fbb_.push_slot::<u64>(ServerVersionCmd::VT_SERVER_TIME_UTC, server_time_utc, 0);
  }
  #[inline]
  pub fn add_server_time(&mut self, server_time: u64) {
    self.fbb_.push_slot::<u64>(ServerVersionCmd::VT_SERVER_TIME, server_time, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ServerVersionCmdBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ServerVersionCmdBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ServerVersionCmd<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ServerVersionCmd<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ServerVersionCmd");
      ds.field("server_version", &self.server_version());
      ds.field("client_wan_ip", &self.client_wan_ip());
      ds.field("client_wan_port", &self.client_wan_port());
      ds.field("heart_type", &self.heart_type());
      ds.field("heart_client_interval", &self.heart_client_interval());
      ds.field("check_server_interval", &self.check_server_interval());
      ds.field("server_id", &self.server_id());
      ds.field("server_time_utc", &self.server_time_utc());
      ds.field("server_time", &self.server_time());
      ds.finish()
  }
}
pub enum ClientLoginReqOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ClientLoginReq<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ClientLoginReq<'a> {
  type Inner = ClientLoginReq<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ClientLoginReq<'a> {
  pub const VT_CLIENT_VERSION: flatbuffers::VOffsetT = 4;
  pub const VT_USERNAME: flatbuffers::VOffsetT = 6;
  pub const VT_PASSWORD: flatbuffers::VOffsetT = 8;
  pub const VT_AUTH_TYPE: flatbuffers::VOffsetT = 10;
  pub const VT_UNK_EMPTY_STRING: flatbuffers::VOffsetT = 12;
  pub const VT_GAME_ID: flatbuffers::VOffsetT = 14;
  pub const VT_UNK_EMPTY_STRING_3: flatbuffers::VOffsetT = 16;
  pub const VT_UNK_RELATED_TO_UID: flatbuffers::VOffsetT = 18;
  pub const VT_UNK_EMPTY_STRING_5: flatbuffers::VOffsetT = 20;
  pub const VT_CLIENT_WAN_IP: flatbuffers::VOffsetT = 22;
  pub const VT_UNK_HEX: flatbuffers::VOffsetT = 24;
  pub const VT_UNK_HEX_2: flatbuffers::VOffsetT = 26;
  pub const VT_UNK_EMPTY_STRING_8: flatbuffers::VOffsetT = 28;
  pub const VT_OS_VERSION: flatbuffers::VOffsetT = 30;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ClientLoginReq { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ClientLoginReqArgs<'args>
  ) -> flatbuffers::WIPOffset<ClientLoginReq<'bldr>> {
    let mut builder = ClientLoginReqBuilder::new(_fbb);
    if let Some(x) = args.os_version { builder.add_os_version(x); }
    if let Some(x) = args.unk_empty_string_8 { builder.add_unk_empty_string_8(x); }
    if let Some(x) = args.unk_hex_2 { builder.add_unk_hex_2(x); }
    if let Some(x) = args.unk_hex { builder.add_unk_hex(x); }
    if let Some(x) = args.client_wan_ip { builder.add_client_wan_ip(x); }
    if let Some(x) = args.unk_empty_string_5 { builder.add_unk_empty_string_5(x); }
    if let Some(x) = args.unk_related_to_uid { builder.add_unk_related_to_uid(x); }
    if let Some(x) = args.unk_empty_string_3 { builder.add_unk_empty_string_3(x); }
    if let Some(x) = args.game_id { builder.add_game_id(x); }
    if let Some(x) = args.unk_empty_string { builder.add_unk_empty_string(x); }
    builder.add_auth_type(args.auth_type);
    if let Some(x) = args.password { builder.add_password(x); }
    if let Some(x) = args.username { builder.add_username(x); }
    if let Some(x) = args.client_version { builder.add_client_version(x); }
    builder.finish()
  }


  #[inline]
  pub fn client_version(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ClientLoginReq::VT_CLIENT_VERSION, None)}
  }
  #[inline]
  pub fn username(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ClientLoginReq::VT_USERNAME, None)}
  }
  #[inline]
  pub fn password(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ClientLoginReq::VT_PASSWORD, None)}
  }
  #[inline]
  pub fn auth_type(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ClientLoginReq::VT_AUTH_TYPE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn unk_empty_string(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ClientLoginReq::VT_UNK_EMPTY_STRING, None)}
  }
  #[inline]
  pub fn game_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ClientLoginReq::VT_GAME_ID, None)}
  }
  #[inline]
  pub fn unk_empty_string_3(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ClientLoginReq::VT_UNK_EMPTY_STRING_3, None)}
  }
  #[inline]
  pub fn unk_related_to_uid(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ClientLoginReq::VT_UNK_RELATED_TO_UID, None)}
  }
  #[inline]
  pub fn unk_empty_string_5(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ClientLoginReq::VT_UNK_EMPTY_STRING_5, None)}
  }
  #[inline]
  pub fn client_wan_ip(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ClientLoginReq::VT_CLIENT_WAN_IP, None)}
  }
  #[inline]
  pub fn unk_hex(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ClientLoginReq::VT_UNK_HEX, None)}
  }
  #[inline]
  pub fn unk_hex_2(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ClientLoginReq::VT_UNK_HEX_2, None)}
  }
  #[inline]
  pub fn unk_empty_string_8(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ClientLoginReq::VT_UNK_EMPTY_STRING_8, None)}
  }
  #[inline]
  pub fn os_version(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ClientLoginReq::VT_OS_VERSION, None)}
  }
}

impl flatbuffers::Verifiable for ClientLoginReq<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("client_version", Self::VT_CLIENT_VERSION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("username", Self::VT_USERNAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("password", Self::VT_PASSWORD, false)?
     .visit_field::<i32>("auth_type", Self::VT_AUTH_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("unk_empty_string", Self::VT_UNK_EMPTY_STRING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("game_id", Self::VT_GAME_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("unk_empty_string_3", Self::VT_UNK_EMPTY_STRING_3, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("unk_related_to_uid", Self::VT_UNK_RELATED_TO_UID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("unk_empty_string_5", Self::VT_UNK_EMPTY_STRING_5, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("client_wan_ip", Self::VT_CLIENT_WAN_IP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("unk_hex", Self::VT_UNK_HEX, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("unk_hex_2", Self::VT_UNK_HEX_2, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("unk_empty_string_8", Self::VT_UNK_EMPTY_STRING_8, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("os_version", Self::VT_OS_VERSION, false)?
     .finish();
    Ok(())
  }
}
pub struct ClientLoginReqArgs<'a> {
    pub client_version: Option<flatbuffers::WIPOffset<&'a str>>,
    pub username: Option<flatbuffers::WIPOffset<&'a str>>,
    pub password: Option<flatbuffers::WIPOffset<&'a str>>,
    pub auth_type: i32,
    pub unk_empty_string: Option<flatbuffers::WIPOffset<&'a str>>,
    pub game_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub unk_empty_string_3: Option<flatbuffers::WIPOffset<&'a str>>,
    pub unk_related_to_uid: Option<flatbuffers::WIPOffset<&'a str>>,
    pub unk_empty_string_5: Option<flatbuffers::WIPOffset<&'a str>>,
    pub client_wan_ip: Option<flatbuffers::WIPOffset<&'a str>>,
    pub unk_hex: Option<flatbuffers::WIPOffset<&'a str>>,
    pub unk_hex_2: Option<flatbuffers::WIPOffset<&'a str>>,
    pub unk_empty_string_8: Option<flatbuffers::WIPOffset<&'a str>>,
    pub os_version: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ClientLoginReqArgs<'a> {
  #[inline]
  fn default() -> Self {
    ClientLoginReqArgs {
      client_version: None,
      username: None,
      password: None,
      auth_type: 0,
      unk_empty_string: None,
      game_id: None,
      unk_empty_string_3: None,
      unk_related_to_uid: None,
      unk_empty_string_5: None,
      client_wan_ip: None,
      unk_hex: None,
      unk_hex_2: None,
      unk_empty_string_8: None,
      os_version: None,
    }
  }
}

pub struct ClientLoginReqBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ClientLoginReqBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_client_version(&mut self, client_version: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ClientLoginReq::VT_CLIENT_VERSION, client_version);
  }
  #[inline]
  pub fn add_username(&mut self, username: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ClientLoginReq::VT_USERNAME, username);
  }
  #[inline]
  pub fn add_password(&mut self, password: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ClientLoginReq::VT_PASSWORD, password);
  }
  #[inline]
  pub fn add_auth_type(&mut self, auth_type: i32) {
    self.fbb_.push_slot::<i32>(ClientLoginReq::VT_AUTH_TYPE, auth_type, 0);
  }
  #[inline]
  pub fn add_unk_empty_string(&mut self, unk_empty_string: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ClientLoginReq::VT_UNK_EMPTY_STRING, unk_empty_string);
  }
  #[inline]
  pub fn add_game_id(&mut self, game_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ClientLoginReq::VT_GAME_ID, game_id);
  }
  #[inline]
  pub fn add_unk_empty_string_3(&mut self, unk_empty_string_3: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ClientLoginReq::VT_UNK_EMPTY_STRING_3, unk_empty_string_3);
  }
  #[inline]
  pub fn add_unk_related_to_uid(&mut self, unk_related_to_uid: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ClientLoginReq::VT_UNK_RELATED_TO_UID, unk_related_to_uid);
  }
  #[inline]
  pub fn add_unk_empty_string_5(&mut self, unk_empty_string_5: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ClientLoginReq::VT_UNK_EMPTY_STRING_5, unk_empty_string_5);
  }
  #[inline]
  pub fn add_client_wan_ip(&mut self, client_wan_ip: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ClientLoginReq::VT_CLIENT_WAN_IP, client_wan_ip);
  }
  #[inline]
  pub fn add_unk_hex(&mut self, unk_hex: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ClientLoginReq::VT_UNK_HEX, unk_hex);
  }
  #[inline]
  pub fn add_unk_hex_2(&mut self, unk_hex_2: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ClientLoginReq::VT_UNK_HEX_2, unk_hex_2);
  }
  #[inline]
  pub fn add_unk_empty_string_8(&mut self, unk_empty_string_8: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ClientLoginReq::VT_UNK_EMPTY_STRING_8, unk_empty_string_8);
  }
  #[inline]
  pub fn add_os_version(&mut self, os_version: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ClientLoginReq::VT_OS_VERSION, os_version);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ClientLoginReqBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ClientLoginReqBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ClientLoginReq<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ClientLoginReq<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ClientLoginReq");
      ds.field("client_version", &self.client_version());
      ds.field("username", &self.username());
      ds.field("password", &self.password());
      ds.field("auth_type", &self.auth_type());
      ds.field("unk_empty_string", &self.unk_empty_string());
      ds.field("game_id", &self.game_id());
      ds.field("unk_empty_string_3", &self.unk_empty_string_3());
      ds.field("unk_related_to_uid", &self.unk_related_to_uid());
      ds.field("unk_empty_string_5", &self.unk_empty_string_5());
      ds.field("client_wan_ip", &self.client_wan_ip());
      ds.field("unk_hex", &self.unk_hex());
      ds.field("unk_hex_2", &self.unk_hex_2());
      ds.field("unk_empty_string_8", &self.unk_empty_string_8());
      ds.field("os_version", &self.os_version());
      ds.finish()
  }
}
pub enum ClientTravelCmdOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ClientTravelCmd<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ClientTravelCmd<'a> {
  type Inner = ClientTravelCmd<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ClientTravelCmd<'a> {
  pub const VT_UNK_131644: flatbuffers::VOffsetT = 4;
  pub const VT_PLAYER_UID: flatbuffers::VOffsetT = 6;
  pub const VT_UNK_EMPTY_STRING: flatbuffers::VOffsetT = 8;
  pub const VT_SERVER_ADDR: flatbuffers::VOffsetT = 10;
  pub const VT_UNK_EMPTY_STRING_2: flatbuffers::VOffsetT = 12;
  pub const VT_UNK_EMPTY_STRING_3: flatbuffers::VOffsetT = 14;
  pub const VT_PLAYER_ROLE_ID: flatbuffers::VOffsetT = 16;
  pub const VT_PLAYER_CHARACTER_BP: flatbuffers::VOffsetT = 18;
  pub const VT_COMPRESSED_DATA_BLOB: flatbuffers::VOffsetT = 20;
  pub const VT_UNK_322: flatbuffers::VOffsetT = 22;
  pub const VT_UNK_1: flatbuffers::VOffsetT = 24;
  pub const VT_UNK_CDCDCDCD: flatbuffers::VOffsetT = 26;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ClientTravelCmd { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ClientTravelCmdArgs<'args>
  ) -> flatbuffers::WIPOffset<ClientTravelCmd<'bldr>> {
    let mut builder = ClientTravelCmdBuilder::new(_fbb);
    builder.add_unk_cdcdcdcd(args.unk_cdcdcdcd);
    builder.add_unk_1(args.unk_1);
    builder.add_unk_322(args.unk_322);
    if let Some(x) = args.compressed_data_blob { builder.add_compressed_data_blob(x); }
    if let Some(x) = args.player_character_bp { builder.add_player_character_bp(x); }
    builder.add_player_role_id(args.player_role_id);
    if let Some(x) = args.unk_empty_string_3 { builder.add_unk_empty_string_3(x); }
    if let Some(x) = args.unk_empty_string_2 { builder.add_unk_empty_string_2(x); }
    if let Some(x) = args.server_addr { builder.add_server_addr(x); }
    if let Some(x) = args.unk_empty_string { builder.add_unk_empty_string(x); }
    if let Some(x) = args.player_uid { builder.add_player_uid(x); }
    builder.add_unk_131644(args.unk_131644);
    builder.finish()
  }


  #[inline]
  pub fn unk_131644(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ClientTravelCmd::VT_UNK_131644, Some(0)).unwrap()}
  }
  #[inline]
  pub fn player_uid(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ClientTravelCmd::VT_PLAYER_UID, None)}
  }
  #[inline]
  pub fn unk_empty_string(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ClientTravelCmd::VT_UNK_EMPTY_STRING, None)}
  }
  #[inline]
  pub fn server_addr(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ClientTravelCmd::VT_SERVER_ADDR, None)}
  }
  #[inline]
  pub fn unk_empty_string_2(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ClientTravelCmd::VT_UNK_EMPTY_STRING_2, None)}
  }
  #[inline]
  pub fn unk_empty_string_3(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ClientTravelCmd::VT_UNK_EMPTY_STRING_3, None)}
  }
  #[inline]
  pub fn player_role_id(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ClientTravelCmd::VT_PLAYER_ROLE_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn player_character_bp(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ClientTravelCmd::VT_PLAYER_CHARACTER_BP, None)}
  }
  #[inline]
  pub fn compressed_data_blob(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(ClientTravelCmd::VT_COMPRESSED_DATA_BLOB, None)}
  }
  #[inline]
  pub fn unk_322(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ClientTravelCmd::VT_UNK_322, Some(0)).unwrap()}
  }
  #[inline]
  pub fn unk_1(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ClientTravelCmd::VT_UNK_1, Some(0)).unwrap()}
  }
  #[inline]
  pub fn unk_cdcdcdcd(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(ClientTravelCmd::VT_UNK_CDCDCDCD, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for ClientTravelCmd<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("unk_131644", Self::VT_UNK_131644, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("player_uid", Self::VT_PLAYER_UID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("unk_empty_string", Self::VT_UNK_EMPTY_STRING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("server_addr", Self::VT_SERVER_ADDR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("unk_empty_string_2", Self::VT_UNK_EMPTY_STRING_2, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("unk_empty_string_3", Self::VT_UNK_EMPTY_STRING_3, false)?
     .visit_field::<i32>("player_role_id", Self::VT_PLAYER_ROLE_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("player_character_bp", Self::VT_PLAYER_CHARACTER_BP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("compressed_data_blob", Self::VT_COMPRESSED_DATA_BLOB, false)?
     .visit_field::<i32>("unk_322", Self::VT_UNK_322, false)?
     .visit_field::<i32>("unk_1", Self::VT_UNK_1, false)?
     .visit_field::<u32>("unk_cdcdcdcd", Self::VT_UNK_CDCDCDCD, false)?
     .finish();
    Ok(())
  }
}
pub struct ClientTravelCmdArgs<'a> {
    pub unk_131644: i32,
    pub player_uid: Option<flatbuffers::WIPOffset<&'a str>>,
    pub unk_empty_string: Option<flatbuffers::WIPOffset<&'a str>>,
    pub server_addr: Option<flatbuffers::WIPOffset<&'a str>>,
    pub unk_empty_string_2: Option<flatbuffers::WIPOffset<&'a str>>,
    pub unk_empty_string_3: Option<flatbuffers::WIPOffset<&'a str>>,
    pub player_role_id: i32,
    pub player_character_bp: Option<flatbuffers::WIPOffset<&'a str>>,
    pub compressed_data_blob: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub unk_322: i32,
    pub unk_1: i32,
    pub unk_cdcdcdcd: u32,
}
impl<'a> Default for ClientTravelCmdArgs<'a> {
  #[inline]
  fn default() -> Self {
    ClientTravelCmdArgs {
      unk_131644: 0,
      player_uid: None,
      unk_empty_string: None,
      server_addr: None,
      unk_empty_string_2: None,
      unk_empty_string_3: None,
      player_role_id: 0,
      player_character_bp: None,
      compressed_data_blob: None,
      unk_322: 0,
      unk_1: 0,
      unk_cdcdcdcd: 0,
    }
  }
}

pub struct ClientTravelCmdBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ClientTravelCmdBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_unk_131644(&mut self, unk_131644: i32) {
    self.fbb_.push_slot::<i32>(ClientTravelCmd::VT_UNK_131644, unk_131644, 0);
  }
  #[inline]
  pub fn add_player_uid(&mut self, player_uid: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ClientTravelCmd::VT_PLAYER_UID, player_uid);
  }
  #[inline]
  pub fn add_unk_empty_string(&mut self, unk_empty_string: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ClientTravelCmd::VT_UNK_EMPTY_STRING, unk_empty_string);
  }
  #[inline]
  pub fn add_server_addr(&mut self, server_addr: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ClientTravelCmd::VT_SERVER_ADDR, server_addr);
  }
  #[inline]
  pub fn add_unk_empty_string_2(&mut self, unk_empty_string_2: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ClientTravelCmd::VT_UNK_EMPTY_STRING_2, unk_empty_string_2);
  }
  #[inline]
  pub fn add_unk_empty_string_3(&mut self, unk_empty_string_3: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ClientTravelCmd::VT_UNK_EMPTY_STRING_3, unk_empty_string_3);
  }
  #[inline]
  pub fn add_player_role_id(&mut self, player_role_id: i32) {
    self.fbb_.push_slot::<i32>(ClientTravelCmd::VT_PLAYER_ROLE_ID, player_role_id, 0);
  }
  #[inline]
  pub fn add_player_character_bp(&mut self, player_character_bp: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ClientTravelCmd::VT_PLAYER_CHARACTER_BP, player_character_bp);
  }
  #[inline]
  pub fn add_compressed_data_blob(&mut self, compressed_data_blob: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ClientTravelCmd::VT_COMPRESSED_DATA_BLOB, compressed_data_blob);
  }
  #[inline]
  pub fn add_unk_322(&mut self, unk_322: i32) {
    self.fbb_.push_slot::<i32>(ClientTravelCmd::VT_UNK_322, unk_322, 0);
  }
  #[inline]
  pub fn add_unk_1(&mut self, unk_1: i32) {
    self.fbb_.push_slot::<i32>(ClientTravelCmd::VT_UNK_1, unk_1, 0);
  }
  #[inline]
  pub fn add_unk_cdcdcdcd(&mut self, unk_cdcdcdcd: u32) {
    self.fbb_.push_slot::<u32>(ClientTravelCmd::VT_UNK_CDCDCDCD, unk_cdcdcdcd, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ClientTravelCmdBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ClientTravelCmdBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ClientTravelCmd<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ClientTravelCmd<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ClientTravelCmd");
      ds.field("unk_131644", &self.unk_131644());
      ds.field("player_uid", &self.player_uid());
      ds.field("unk_empty_string", &self.unk_empty_string());
      ds.field("server_addr", &self.server_addr());
      ds.field("unk_empty_string_2", &self.unk_empty_string_2());
      ds.field("unk_empty_string_3", &self.unk_empty_string_3());
      ds.field("player_role_id", &self.player_role_id());
      ds.field("player_character_bp", &self.player_character_bp());
      ds.field("compressed_data_blob", &self.compressed_data_blob());
      ds.field("unk_322", &self.unk_322());
      ds.field("unk_1", &self.unk_1());
      ds.field("unk_cdcdcdcd", &self.unk_cdcdcdcd());
      ds.finish()
  }
}
pub enum ClientKeepAliveCmdOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ClientKeepAliveCmd<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ClientKeepAliveCmd<'a> {
  type Inner = ClientKeepAliveCmd<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ClientKeepAliveCmd<'a> {
  pub const VT_UNK_1: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ClientKeepAliveCmd { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ClientKeepAliveCmdArgs
  ) -> flatbuffers::WIPOffset<ClientKeepAliveCmd<'bldr>> {
    let mut builder = ClientKeepAliveCmdBuilder::new(_fbb);
    builder.add_unk_1(args.unk_1);
    builder.finish()
  }


  #[inline]
  pub fn unk_1(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(ClientKeepAliveCmd::VT_UNK_1, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for ClientKeepAliveCmd<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("unk_1", Self::VT_UNK_1, false)?
     .finish();
    Ok(())
  }
}
pub struct ClientKeepAliveCmdArgs {
    pub unk_1: u32,
}
impl<'a> Default for ClientKeepAliveCmdArgs {
  #[inline]
  fn default() -> Self {
    ClientKeepAliveCmdArgs {
      unk_1: 0,
    }
  }
}

pub struct ClientKeepAliveCmdBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ClientKeepAliveCmdBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_unk_1(&mut self, unk_1: u32) {
    self.fbb_.push_slot::<u32>(ClientKeepAliveCmd::VT_UNK_1, unk_1, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ClientKeepAliveCmdBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ClientKeepAliveCmdBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ClientKeepAliveCmd<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ClientKeepAliveCmd<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ClientKeepAliveCmd");
      ds.field("unk_1", &self.unk_1());
      ds.finish()
  }
}
